<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <title>Document</title>
</head>
<body>
    <div id="chart"></div>
    <script type="application/javascript">
        var width = 500, height=500;
        colors = {
            "INDOOR": '#ff9587',
            "OUTDOOR": '#0dce72',
            "LIFESTYLE": 'lightblue'
        };

        var svg = d3.select('#chart')
            .append('svg')
            .attr('height',height)
            .attr('width',width)
            .append('g');

        var radiusScale = d3.scaleSqrt().domain([0, 100]).range([10, 50]);
        
        var simulation = d3.forceSimulation()
        .force("x", d3.forceX(width / 2).strength(0.01))
        .force("y", d3.forceY(height / 2).strength(0.01))
        .force("cluster", forceCluster())
        .force("collide", forceCollide());

        function centroid(nodes) {
            let x = 0;
            let y = 0;
            let z = 0;
            for (const d of nodes) {
            let k = d.r ** 2;
            x += d.x * k;
            y += d.y * k;
            z += k;
            }
            return {x: x / z, y: y / z};
        }

        function forceCluster() {
            const strength = 0.2;
            let nodes;

            function force(alpha) {
                const centroids = d3.rollup(nodes, centroid, d => d.data.group);
                const l = alpha * strength;
                for (const d of nodes) {
                    const {x: cx, y: cy} = centroids.get(d.data.group);
                    d.vx -= (d.x - cx) * l;
                    d.vy -= (d.y - cy) * l;
                }
            }
            force.initialize = _ => nodes = _;
            return force;
        }
        function forceCollide() {
            const alpha = 0.4; // fixed for greater rigidity!
            const padding1 = 2; // separation between same-color nodes
            const padding2 = 6; // separation between different-color nodes
            let nodes;
            let maxRadius;

            function force() {
                const quadtree = d3.quadtree(nodes, d => d.x, d => d.y);
                for (const d of nodes) {
                const r = d.r + maxRadius;
                const nx1 = d.x - r, ny1 = d.y - r;
                const nx2 = d.x + r, ny2 = d.y + r;
                quadtree.visit((q, x1, y1, x2, y2) => {
                    if (!q.length) do {
                    if (q.data !== d) {
                        const r = d.r + q.data.r + (d.data.group === q.data.data.group ? padding1 : padding2);
                        let x = d.x - q.data.x, y = d.y - q.data.y, l = Math.hypot(x, y);
                        if (l < r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l, d.y -= y *= l;
                        q.data.x += x, q.data.y += y;
                        }
                    }
                    } while (q = q.next);
                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
                }
            }
            force.initialize = _ => maxRadius = d3.max(nodes = _, d => d.r) + Math.max(padding1, padding2);
            return force;
        }

        d3.queue()
        .defer(d3.json, 'data.json')
        .await(ready);

        function ready(err, root) {
            var nodes = d3.hierarchy(root).leaves();
            simulation.nodes(nodes).on('tick',tick);

            var svgNodes = svg.selectAll('.node')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class','node')
            .attr('id', d => d.data.name)
            .on('click',click)

            svgNodes.append('circle')
            .attr('class', d => d.parent.data.name)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr('r', d => radiusScale(d.data.value))
            .style('fill', d => colors[d.parent.data.name.toUpperCase()])

            svgNodes.append('text')
            .attr('font-size','12px')
            .style('text-anchor','middle')
            .text(d => d.data.value)

            function tick(){
                svgNodes.attr('transform', d => "translate("+d.x+","+d.y+")");
            }

            function clickCheck(d){
                var expandedNode = nodes.find(node => node.data['activated'] === true);
                if (expandedNode){
                    d3.select("#"+expandedNode.data.name)
                        .select('circle')
                        .transition()
                        .duration(200)
                        .attr('r', d => radiusScale(d.data['old_value']));

                    expandedNode.data.value = expandedNode.data['old_value'];
                    expandedNode.data['activated'] = false;
                }
            }

            function click(d){
                clickCheck(d);
                if (d.data['activated']){
                    d3.select(this)
                        .select('circle')
                        .transition()
                        .duration(200)
                        .attr('r', d => radiusScale(d.data['old_value']));
                }
                else{
                    d.data['activated'] = true;
                    d.data['old_value'] = d.data.value;
                    d.data.value = 300;
                    d3.select(this)
                        .select('circle')
                        .transition()
                        .duration(200)
                        .attr('r',d => radiusScale(d.data.value))
                }
                console.log("Clicked"+d.data.name)
            }

            simulation.nodes(nodes)
            simulation.alphaTarget(1).restart()
        }


    </script>
</body>
</html>